---
created: ["2023-06-15 13:34"]
share: true
---

up::

# ❗ Information
Related to:: 
Tags:: 

___
# 🌍 Problem Definition

> [!QUESTION] Problem
> Draw the tree illustrating the process generated by the count-change procedure of 1.2.2 in making change for 11 cents. What are the orders of growth of the space and number of steps used by this process as the amount to be changed increases?

The code:
```Scheme
#lang sicp

(define (cc amt k)
  (cond ((= amt 0) 1)
        ((or (< amt 0) (= k 0)) 0)
        (else (+ (cc amt (- k 1))
                 (cc (- amt (select k)) k)))))

(define (select k)
  (cond ((= k 1) 1)
        ((= k 2) 5)
        ((= k 3) 10)
        ((= k 4) 25)
        ((= k 5) 50)))
```

## 🔑 **Key Points of Understanding**

# 🔍 Solutions

#### Text Trace
- Here is the trace from Dr Racket:
- In graph view below, you can see more clearly.
```Scheme
>(cc 11 5)
> (cc 11 4)
> >(cc 11 3)
> > (cc 11 2)
> > >(cc 11 1)
> > > (cc 11 0)
< < < 0
> > > (cc 10 1)
> > > >(cc 10 0)
< < < <0
> > > >(cc 9 1)
> > > > (cc 9 0)
< < < < 0
> > > > (cc 8 1)
> > > > >(cc 8 0)
< < < < <0
> > > > >(cc 7 1)
> > > > > (cc 7 0)
< < < < < 0
> > > > > (cc 6 1)
> > > >[10] (cc 6 0)
< < < <[10] 0
> > > >[10] (cc 5 1)
> > > >[11] (cc 5 0)
< < < <[11] 0
> > > >[11] (cc 4 1)
> > > >[12] (cc 4 0)
< < < <[12] 0
> > > >[12] (cc 3 1)
> > > >[13] (cc 3 0)
< < < <[13] 0
> > > >[13] (cc 2 1)
> > > >[14] (cc 2 0)
< < < <[14] 0
> > > >[14] (cc 1 1)
> > > >[15] (cc 1 0)
< < < <[15] 0
> > > >[15] (cc 0 1)
< < < <[15] 1
< < < <[14] 1
< < < <[13] 1
< < < <[12] 1
< < < <[11] 1
< < < <[10] 1
< < < < < 1
< < < < <1
< < < < 1
< < < <1
< < < 1
< < <1
> > >(cc 6 2)
> > > (cc 6 1)
> > > >(cc 6 0)
< < < <0
> > > >(cc 5 1)
> > > > (cc 5 0)
< < < < 0
> > > > (cc 4 1)
> > > > >(cc 4 0)
< < < < <0
> > > > >(cc 3 1)
> > > > > (cc 3 0)
< < < < < 0
> > > > > (cc 2 1)
> > > >[10] (cc 2 0)
< < < <[10] 0
> > > >[10] (cc 1 1)
> > > >[11] (cc 1 0)
< < < <[11] 0
> > > >[11] (cc 0 1)
< < < <[11] 1
< < < <[10] 1
< < < < < 1
< < < < <1
< < < < 1
< < < <1
< < < 1
> > > (cc 1 2)
> > > >(cc 1 1)
> > > > (cc 1 0)
< < < < 0
> > > > (cc 0 1)
< < < < 1
< < < <1
> > > >(cc -4 2)
< < < <0
< < < 1
< < <2
< < 3
> > (cc 1 3)
> > >(cc 1 2)
> > > (cc 1 1)
> > > >(cc 1 0)
< < < <0
> > > >(cc 0 1)
< < < <1
< < < 1
> > > (cc -4 2)
< < < 0
< < <1
> > >(cc -9 3)
< < <0
< < 1
< <4
> >(cc -14 4)
< <0
< 4
> (cc -39 5)
< 0
<4
4
```
- Here are few things to note:
	- The indentation shows the level within the tree:
		```Scheme
>(cc 11 5) ; level 0
> (cc 11 4)  ; level 1
	  ```
	- < arrays return a value, meaning the call before it was a leaf node
```Scheme
> > > (cc 11 0)
< < < 0
```

#### GraphViz Trace
- Here is the result in graph:
![Pasted image 20230615135011.png](./40-referenceVAULTS/Resource%20Library/Images/Pasted%20image%2020230615135011.png)

#### Orders of growth of space
- Since this is a recursive process, the orders of growth of space will be proportional to the depth of calls.
- It is easy to see that the longest series of call will be when making the change of amount n using only pennies.
- The order of growth of space for cc will be $\Theta$(n)

#### Orders of growth of numbers of steps
- For estimating the orders of growth of number of steps, we will focus on counting the numbers of call to cc.
- The *first step* is to get an intuitive understanding of the shape of the growth by exploring  low dimension that we can plot. 
	- Let's start with graphing the shape of the trees when using only pennies by charting the tree for (cc 6 1)
		![300](./40-referenceVAULTS/Resource%20Library/Images/Pasted%20image%2020230615150145.png)
		- Colors in this chart indicate the number of `kinds-of-coins`
	- The process here is linear: every node is splitting into 2 sub-step but only with `(cc x 1)` on the right will recurse deeper. All the `(cc x 0)` are leaves of this tree since it indicates that are no more type of coins to use.
	- From this graph, we can notice several things:
		- there are 6 blue nodes from `(cc 6 1)` to `(cc 1 1)`
		- there are 6 gray nodes from `(cc 6 0)` to `(cc 1 0)`
		- there is one dark gray node `(cc 0 1)` with amount of 0 , indicating a solution!! ( finally we can reach to zero by making changes.)
	- If T(n,m) is the number of call to `cc` for amount `n` and `m`  type of coin, we can see that:
		- T(6,1) = 2 x 6 + 1
	- From there, we can generalize to any amount m using only pennies:
		- T(n,1) = 2 x n + 1
- As the *second step*, let's see how things work with 2 kinds of coins.
	- Let's draw the tree for `(cc 12 2)` and arranging the nodes a. little, we see that we have a neat 2 dimensional array:
		![Pasted image 20230615151036.png](./40-referenceVAULTS/Resource%20Library/Images/Pasted%20image%2020230615151036.png)
	 - Let's break it down:
		 - There are 4 green nodes for `(cc x 2)` corresponding to how many time you can subtract a nickel (5 pennies) from 12, plus one (the negative amount one)
		 - Then for each of the green node, there is the option of using only pennies, which is the case we looked at first.
	- For an amount n, there is at most Floor(n/5) + 1 , you can subtract nickels from it before reaching to zero or a negative value.
		- By simplifying a little and ignoring the floor that won't impact a lot the result when the number grows larger, we can compute T(n,2):
			- there is $\frac{n}{5}$ + 1 green node
			- for each green node, there is a node for pennies that start from the value n
		- So  we can rewrite this as an equation and simplify it:
			![Pasted image 20230615151748.png](./40-referenceVAULTS/Resource%20Library/Images/Pasted%20image%2020230615151748.png)
			- Then we can define the exact number of steps for a given number n:
				![200](./40-referenceVAULTS/Resource%20Library/Images/Pasted%20image%2020230615152228.png)
			- Which means that for 2 types of coins, the orders of growth of number of steps is:
				![200](./40-referenceVAULTS/Resource%20Library/Images/Pasted%20image%2020230615152341.png)
- As the *third step*, lets have a look at the T(n,3).
	- Our 3rd kind of denomination was 10 pennies, so we can have at most n/10 + 1 green nodes.
	- So, For T(n,3):
		![400](./40-referenceVAULTS/Resource%20Library/Images/Pasted%20image%2020230615152729.png)
	 - If you take the trouble to expand the equation, you will find that:
		 ![200](./40-referenceVAULTS/Resource%20Library/Images/Pasted%20image%2020230615152830.png)

- As the *rest of the steps*, you can continue applying the formula, you will see:
		![400](./40-referenceVAULTS/Resource%20Library/Images/Pasted%20image%2020230615153003.png)
	- Once , you are done with all the expansions, you will see that the order of growth of number of steps is:
			![200](./40-referenceVAULTS/Resource%20Library/Images/Pasted%20image%2020230615153117.png)
- Overall, this is not only a very slow process, it is also a very inefficient way to implement this computation, because of all the repetitions.
# 🧠 Ideas about Problem
- Can we do it in $\Theta$($n^2$)?
- Yes we can here is a step by step improvement.

- The original form:
```Scheme
(define (count-change amount)
  (cc amount 5))

;; Original version of cc with counter added
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
	((or (< amount 0) (= kinds-of-coins 0)) 0)
	(else (+ (cc amount
		     (- kinds-of-coins 1))
		 (cc (- amount
			(first-denomination kinds-of-coins))
		     kinds-of-coins)))))
```

- Second version:
	- improvement is made to T(n,1)  by eliminating the subtrees with root node `(cc amount 1)`
		```Scheme
;; Second version of cc: 
;; ---------------------
;; condition
;;   ((= amount 0) 1)
;; replaced by
;;   ((or (= amount 0) (= kinds-of-coins 1)) 1);
;; this eliminates all subtrees with root node (cc amount 1)
;; and reduces number of steps significantly
(define (cc amount kinds-of-coins)
  (set! counter (+ counter 1))
  (cond ((or (= amount 0) (= kinds-of-coins 1))  1)
	((or (< amount 0) (= kinds-of-coins 0)) 0)
	(else (+ (cc amount
		     (- kinds-of-coins 1))
		 (cc (- amount
			(first-denomination kinds-of-coins))
		     kinds-of-coins)))))
```
	- This way we have reduces T(n,1) = $\Theta(n)$ to $\Theta(1)$

- Third version:
	- improvement is made to T(n,2) by eliminating the subtrees with root node `(cc amount 2)`
		```Scheme
;; Third version: 
;; --------------
;; additional condition
;;   ((= kinds-of-coins 2) (+ 1 (quotient amount 5)))
;; eliminates all subtrees with root node (cc amount 2)
;; and reduces number of steps even further
(define (cc amount kinds-of-coins)
  (set! counter (+ counter 1))
  (cond ((= kinds-of-coins 2) (+ 1 (quotient amount 5)))
	((or (= kinds-of-coins 1) (= amount 0)) 1)
	((or (< amount 0) (= kinds-of-coins 0)) 0)
	(else (+ (cc amount
		     (- kinds-of-coins 1))
		 (cc (- amount
			(first-denomination kinds-of-coins))
		     kinds-of-coins)))))
```
	- This way T(n,2) = $\Theta(n^2)$ to $\Theta(n)$

- Fourth version:
	- improvement is made to T(n,3) by eliminating the subtree with root node `(cc amount 3)`

		```Scheme
;; Fourth version: 
;; ---------------
;; additional condition
;; eliminates all subtrees with root node (cc amount 3)
;; and short-circuits still more steps
(define (cc amount kinds-of-coins)
  (set! counter (+ counter 1))
  (cond ((= kinds-of-coins 3) (+ (* (quotient amount 10)
				    (quotient amount 5))
				 (- (square (quotient amount 10)))
				 (quotient amount 5)
				 1))
	((= kinds-of-coins 2) (+ 1 (quotient amount 5)))
	((or (= kinds-of-coins 1) (= amount 0)) 1)
	((or (< amount 0) (= kinds-of-coins 0)) 0)
	(else (+ (cc amount
		     (- kinds-of-coins 1))
		 (cc (- amount
			(first-denomination kinds-of-coins))
		     kinds-of-coins)))))
```

	- This way we reduce T(n,3) = $\Theta(n^3)$ to $\Theta(n^2)$

# 🔗 Related Applications
Here is the link, the problem refers to!
![Tree Recursion#^cdcde0](Tree%20Recursion.md#^cdcde0)